<!doctype html>
<html lang="pt-BR">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Piper Minimal TTS</title>
<style>
  :root{--bg:#0e1726;--card:#121c2f;--txt:#e8eefc;--accent:#6b5bff}
  body{background:var(--bg);color:var(--txt);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:0;padding:20px}
  h1{margin:0 0 16px}
  .card{max-width:720px;margin:0 auto;background:var(--card);border-radius:16px;padding:20px;box-shadow:0 10px 24px rgba(0,0,0,.35)}
  textarea{width:100%;height:180px;border:0;border-radius:12px;padding:12px;font-size:18px;margin-bottom:12px;background:#19253b;color:var(--txt)}
  .btns{display:flex;gap:12px;flex-wrap:wrap}
  button{padding:14px 22px;border-radius:12px;border:0;font-weight:700;font-size:17px;cursor:pointer;background:var(--accent);color:#fff}
  audio{width:100%;margin-top:16px}
  .note{opacity:.8;font-size:13px;margin-top:10px}
</style>

<div class="card">
  <h1>Piper TTS Browser</h1>
  <textarea id="text">Olá, este é meu teste em Piper WebAssembly usando voz pt_BR-edresson-low.</textarea>
  <div class="btns">
    <button id="btn">Gerar Áudio</button>
    <button id="dl">Baixar MP3</button>
  </div>
  <audio id="player" controls></audio>
  <div class="note">Primeiro uso baixa o modelo. Depois funciona offline.</div>
</div>

<!-- Import map: força o onnxruntime a usar os seus arquivos locais -->
<script type="importmap">
{
  "imports": {
    "onnxruntime-web": "./vendor/onnx/ort-wasm.mjs",
    "@onnxruntime/web": "./vendor/onnx/ort-wasm.mjs",
    "onnxruntime-web/webgpu": "./vendor/onnx/ort-wasm.mjs",
    "onnxruntime-web/webnn": "./vendor/onnx/ort-wasm.mjs",
    "onnxruntime-web/wasm": "./vendor/onnx/ort-wasm.mjs",

    "https://cdnjs.cloudflare.com/ajax/libs/onnxruntime-web/1.18.0/ort-wasm-simd-threaded.mjs": "./vendor/onnx/ort-wasm-simd-threaded.mjs",
    "https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/ort-wasm-simd-threaded.jsep.mjs": "./vendor/onnx/ort-wasm-simd-threaded.mjs",
    "https://unpkg.com/onnxruntime-web@1.18.0/dist/ort-wasm-simd-threaded.jsep.mjs": "./vendor/onnx/ort-wasm-simd-threaded.mjs"
  }
}
</script>

<script>
  // Alguns builds do ORT leem essas flags cedo; isso ajuda a evitar tentativas de threads.
  (self.ort ||= { env: { wasm: {} } });
  ort.env.wasm.numThreads = 1;
  ort.env.wasm.simd = false;
  ort.env.wasm.proxy = false;
</script>


<script type="module">
  // ===== CONFIG =====
  const MODEL_BASE = "https://eudantas2024.github.io/novoaudio/models/pt_BR/";
  const VOICE_ID   = "pt_BR-edresson-low";

  // ONNX local (ajuda alguns ambientes; seguro manter)
  import "./vendor/onnx/ort-wasm.js";
  import "./vendor/onnx/ort-wasm.mjs";

  // Piper TTS hospedado no seu repositório
  const piperModule = await import("./vendor/piper/piper-tts-web.js");
  const tts = piperModule.default || piperModule; // compat: default/named

  // Algumas versões expõem 'configure'; se existir, aponta pro seu diretório de modelos
  if (typeof tts.configure === "function") {
    try { tts.configure({ modelBaseUrl: MODEL_BASE }); } catch {}
  }

  // ---- lógica principal minimalista ----
  const player = document.getElementById("player");
  let lastWavBlob = null;

  async function ensureModel() {
    // baixa e guarda offline (IndexedDB); versões antigas ignoram, mas ok
    if (typeof tts.download === "function") {
      try { await tts.download(VOICE_ID, ()=>{}); } catch {}
    }
  }

  async function generate() {
    const text = document.getElementById("text").value.trim();
    if (!text) return;
    await ensureModel();

    // Chamada de síntese
    const wavBlob = await tts.predict({
      text,
      voiceId: VOICE_ID
      // versões novas aceitam { rate, volume } se quiser depois
    });

    lastWavBlob = wavBlob;
    player.src = URL.createObjectURL(wavBlob); // MANUAL play (você escolheu 2)
  }

  document.getElementById("btn").addEventListener("click", generate);

  // --- MP3 via lamejs (CDN leve) ---
  import "https://cdn.jsdelivr.net/gh/zhuker/lamejs@master/lame.all.js";

  function parseWavToPCM16(wavBuffer){
    const dv = new DataView(wavBuffer);
    // encontrar o chunk 'data'
    let pos = 12;
    while (pos < dv.byteLength){
      const id   = dv.getUint32(pos, false);
      const size = dv.getUint32(pos+4, true);
      if (id === 0x64617461) { // 'data'
        const pcm = new Int16Array(wavBuffer, pos+8, size/2);
        const sampleRate = dv.getUint32(24, true);
        const channels = dv.getUint16(22, true);
        return { pcm, sampleRate, channels };
      }
      pos += 8 + size;
    }
    throw new Error("WAV inválido: chunk data não encontrado");
  }

  function encodeMp3({ pcm, sampleRate, channels }){
    let mono = pcm;
    if (channels === 2){
      const m = new Int16Array(pcm.length/2);
      for (let i=0,j=0;i<pcm.length;i+=2,j++) m[j] = (pcm[i]+pcm[i+1])>>1;
      mono = m;
    }
    const enc = new lamejs.Mp3Encoder(1, sampleRate, 128);
    const frame = 1152;
    const out = [];
    for (let i=0;i<mono.length;i+=frame){
      const chunk = mono.subarray(i, i+frame);
      const buf = enc.encodeBuffer(chunk);
      if (buf.length) out.push(new Int8Array(buf));
    }
    const end = enc.flush(); if (end.length) out.push(new Int8Array(end));
    let total=0; out.forEach(b=> total+=b.length);
    const u8 = new Uint8Array(total);
    let off=0; out.forEach(b=>{ u8.set(b,off); off+=b.length; });
    return new Blob([u8], { type:"audio/mpeg" });
  }

  document.getElementById("dl").addEventListener("click", async ()=>{
    if (!lastWavBlob) return;
    const ab = await lastWavBlob.arrayBuffer();
    const parts = parseWavToPCM16(ab);
    const mp3 = encodeMp3(parts);
    const url = URL.createObjectURL(mp3);
    const a = document.createElement("a");
    a.href = url; a.download = "voz.mp3";
    document.body.appendChild(a); a.click();
    a.remove(); URL.revokeObjectURL(url);
  });
</script>
</html>
